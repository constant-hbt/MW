<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main World</title>
    <!--Unity na pagina-->
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <script src="TemplateData/UnityProgress.js"></script>
    <script src="%UNITY_WEBGL_LOADER_URL%"></script>

    
    <script>
        var unityInstance = UnityLoader.instantiate("unityContainer", "%UNITY_WEBGL_BUILD_URL%", {onProgress: UnityProgress});
      </script>

      <!--BOOTSTRAP-->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!--JS-->
    <script src="js/acorn_interpreter.js"></script>
    <script src="js/blockly_compressed.js"></script>
    <script src="js/blocks_compressed.js"></script>
    <script src="js/javascript_compressed.js"></script>
    <script src = "msg/js/pt-br.js" > </script> 
    <script src = "js/storage.js" > </script>
    <!--Blocos Customizados-->
      <script src="js/Blocos Personalizados/Definicao_Blocos.js"></script>
      <script src="js/Blocos Personalizados/Estrutura_Blocos.js"></script>
    <!--Fim blocos customizados-->
    <script src="js/focoPagina.js"></script>
    <script src="js/DisableEnableWorkspace.js"></script>
    <script src="js/ControleConclusaoFase.js"></script>

    <!--CSS-->
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<!--Local destinado aos blocos blockly-->
<div id="blocklyDiv" style = " height : 480px ; width : 350px ; " onclick="focusCanvas(0)">

    <xml id="toolbox" style="display: none">
        <category name = "Personagem">
            <block type="avancar" class="bloco" disabled = "true"></block>
            <block type="pular" class="bloco" disabled = "true"></block>
            <block type="pular_frente" class="bloco" disabled = "true"></block>
            <block type="defender" class="bloco" disabled = "true"></block>
            <block type="atacar" class="bloco" disabled = "true"></block>
        </category>
        <category name = "Estruturas">
            <block type="controls_if" class="bloco" disabled = "true"></block>
            <block type="controls_repeat_ext" class="bloco" disabled = "true"></block>
            <block type="math_number" class="bloco" disabled = "true"></block>
        </category>
        <category name ="Condições">
            <block type="ha_inimigos" class="bloco" disabled = "true"></block>
            <block type="nao_ha_inimigos" class="bloco" disabled = "true"></block>
        </category>
      </xml>
     
      
  </div>
  <!--Área responsável por mostrar o código em tempo real-->
  <div>
    <p  id="capacRestanteBloco" hidden = true>Restam <span id="capacidade">0</span> blocos !!</p>
</div>
  <div >
   <p>
    
    <button  id="execute" class="btn btn-danger" onclick="stepCode()" disabled = true>
        <img id="iconPlay" src="img/botãoPlay.png" alt="botao de play">    
        Executar
    </button>
   <!-- <button onclick="resetarEspacoBlockly()" id="reset" disabled = true>Reset</button>-->
   </p>
  
  </div>
  
  <div class="webgl-content" style="margin-left: 200px;float: right; " onclick="focusCanvas(1)">
    <div id="unityContainer" style="width: 960px; height: 600px; "></div>
   
  </div>
    <script>

    var myInterpreter = null;
    var runner;
    var code = '';
    var codeCompleto = '';//Contém o código contido em todas as etapas da fase
    var highlightPause = false;
    var qtdBlocosUsados = 0;//quantidade de blocos usados em cada etapa da fase
    var qtdBlocosMinimos = 0;//quantidade de blocos minimos necessarios para passar de fase
    var qtdBlocosTotais = 0;//quantidade de blocos usados em toda fase(pensando nas fases que ha mais de uma etapa)
    var passeiFase ='';//variavel utilizada para saber se passei ou não de fase
    
    var botaoExecutar = document.getElementById('execute');

                var workspace = Blockly.inject('blocklyDiv',
                    {toolbox: document.getElementById('toolbox'),
                    zoom:
                    {controls: true,
                     wheel: true,
                     startScale: 1.0,
                     maxScale: 3,
                     minScale: 0.3,
                     scaleSpeed: 1.2},
                     trashcan: true,
                     maxBlocks:0 } //define o maximo de bloco que pode ser usado por fase
                     );

                

                function initApi(interpreter , scope){
                    //Adiciona uma função de API ao alert
                    var wrapper = function(text) {
                        return alert(arguments.length ? text : '');
                        };
                        interpreter.setProperty(scope, 'alert',
                             interpreter.createNativeFunction(wrapper));

                    //Adiciona uma função de API para o bloco de prompt
                    var wrapper = function(text){
                        return interpreter.createPrimitive(prompt(text));
                        };
                        interpreter.setProperty(scope, prompt , 
                                 interpreter.createNativeFunction(wrapper));


                        //Adicionando uma função de API para destacar blocos.
                         var wrapper = function(id) {
                                return interpreter.createPrimitive(highlightBlock(id));
                                };
                                interpreter.setProperty(scope, 'highlightBlock',
                                   interpreter.createNativeFunction(wrapper));

                        // MOVIMENTAÇÃO DO PERSONAGEM        
                            
                        //Adicionando uma função de API para movimentação para frente
                        var wrapper = function(){
                            return  unityInstance.SendMessage('playerKnight','Movimentacao' , 'avancar');//arrumar depois para movimentar o player para frente
                        }
                        interpreter.setProperty(scope, 'avancar',
                            interpreter.createNativeFunction(wrapper));

                        //Adicionando uma função de API para pular
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao','puloSimples');
                        }
                        interpreter.setProperty(scope,'pular',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de salto com impulso para frente
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'puloLateral');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'pular_frente',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de defesa
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'defender');
                        }
                        interpreter.setProperty(scope, 'defender',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de ataque
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'atacar');
                        }
                        interpreter.setProperty(scope, 'atacar',
                            interpreter.createNativeFunction(wrapper));

                    // BLOCOS DE CONDIÇÃO

                    //Adicionando uma função de API para bool há inimigos
                    var wrapper = function(){
                            return unityInstance.SendMessage('PlayerController','Movimentacao', 'ha_inimigos');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'ha_inimigos',
                            interpreter.createNativeFunction(wrapper));
                    
                    //Adicionando uma função de API para bool não há inimigos
                    var wrapper = function(){
                            return unityInstance.SendMessage('PlayerController','Movimentacao', 'nao_ha_inimigos');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'nao_ha_inimigos',
                            interpreter.createNativeFunction(wrapper));
                        

                        
                }
                
                //Carregue o intérprete agora e após alterações futuras
                generateCodeAndLoadIntoInterpreter();
                workspace.addChangeListener(function(event){
                    if(!(event instanceof Blockly.Events.Ui)){
                        resetInterpreter();
                        generateCodeAndLoadIntoInterpreter();
                        //habilita o botão de execução somente se houver blocos no espaço de trabalho
                        if(code != ''){
                        botaoExecute.disabled = false;
                        botaoReset.disabled = false;//mexer aqui depois
                        
                    }else{
                        botaoExecute.disabled = true;
                        botaoReset.disabled = true;
                    }///linkar isso ao novo espaco de trabalho

                    }
                });

                //Adiciona destaque ao bloco que esta sendo executado
                function highlightBlock(id) {
                  
                    workspace.highlightBlock(id);
                    highlightPause = true;
                }
                //reseta o interprete de codigo
                function resetInterpreter(){
                    myInterpreter = null;
                    if(runner){
                        clearTimeout(runner);
                        runner = null;
                    }
                }

                function resetStepUi(clearOutput){
                    workspace.highlightBlock(null);
                    highlightPause = false;
                        /*
                    if(clearOutput){
                       // areaTexto.value = 'Saída do programa: \n -----------------------\n'; apagar depois
                    }*/
                }

                function generateCodeAndLoadIntoInterpreter(){
                    //Código JavaScript gerado e analisado
                    
                    Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n'; 
                    Blockly.JavaScript.addReservedWords('highlightBlock');
                    code = Blockly.JavaScript.workspaceToCode(workspace);
                   
                    resetStepUi(true);
                }

                
                //função responsavel pelo execução do blocos
                function stepCode(){
                    codeCompleto += Blockly.JavaScript.workspaceToCode(workspace);
                    qtdBlocosUsados = workspace.getAllBlocks().length;
                    qtdBlocosTotais += qtdBlocosUsados;
                    enviarQtdBlocosUsados(qtdBlocosUsados);


                    unityInstance.SendMessage('playerKnight', 'mudarValidar');
                    if(!myInterpreter){
                        //primeira declaração deste código
                        //limpe a saída do programa
                        resetStepUi(true);
                        execute.disable = 'disable';
                        //E, em seguida, mostre o código gerado em um alerta
                        //Em um tempo limite para permitir que o textarea.value seja redefinido primeiro
                        setTimeout(function(){
                            alert('Pronto para executar o seguinte código\n'+
                                   '===================================\n' + code);

                    highlightPause = false;
                    myInterpreter = new Interpreter(code , initApi);
                    
                    runner = function(){
                        if(myInterpreter){
                            var masCodigo = myInterpreter.step();
                            if(masCodigo){
                                

                                setTimeout(runner,80);//se der erro voltar para 80
                            }else{

                                console.log("PasseiFase = "+ passeiFase);
                                unityInstance.SendMessage('playerKnight', 'respostaInterprete');
                                //faz algo quando o codigo acabar de ser lido (Ex: resetar a area de trabalho ao passar de fase)
                              
                                    /*
                    var verificarConclusaoFase= function (){  
                    if(passeiFase){//se passeiFase() returnar false quer dizer que não passei de fase
                        console.log("Entrei no else if passeiFase = "+ passeiFase);
                                   qtdBlocosTotais = 0;
                               

                               }else if(!passeiFase){
                                   
                                unityInstance.SendMessage("PainelDerrotaFase","ativarFaseIncompleta");
                                unityInstance.SendMessage("playerKnight","retirarVida");
                                resetarEspacoBlockly();
                                   qtdBlocosTotais = 0;

                                   
                               }
                             }
                              setTimeout(verificarConclusaoFase, 1200);
                              console.log("PasseiFaseFinal = "+ passeiFase);
                              */
                            }
                        }
                    };
                    runner();
                },1);
                return;
            }
        }
          

                
               //Atualiza a quantidade de blocos 
                function onchange(event){
                            document.getElementById('capacidade').textContent = 
                                workspace.remainingCapacity();

                        }

                    workspace.addChangeListener(onchange);
               
             

                //funcao responsavel por recriar o workspace toda vez que for iniciar uma nova fase,  alterando o limite de blocos
                function recriarWorkspace(qtdMaxBlocos){// -->  função criada por mim
                    code = '';
                    passeiFase = false;
                    workspace.dispose();
                   workspace = Blockly.inject('blocklyDiv',
                    {toolbox: document.getElementById('toolbox'),
                    zoom:
                    {controls: true,
                     wheel: true,
                     startScale: 1.0,
                     maxScale: 3,
                     minScale: 0.3,
                     scaleSpeed: 1.2},
                     trashcan: true,
                     maxBlocks:qtdMaxBlocos } //define o maximo de bloco que pode ser usado por fase
                     );

                     document.getElementById('capacidade').innerHTML =  workspace.remainingCapacity();
                        //aplica a funcao ao novo espaco de trabalho
                     function onchange(event){
                            document.getElementById('capacidade').textContent = 
                                workspace.remainingCapacity();//funcao responsavel por diminuir o numero de blocos disponiveis cada vez que um bloco é acrescentado ao espaco de trabalho
                        }

                    workspace.addChangeListener(onchange);
                    onchange();

                    workspace.addChangeListener(function(event){
                    if(!(event instanceof Blockly.Events.Ui)){
                        resetInterpreter();
                        generateCodeAndLoadIntoInterpreter();
                        //habilita o botão de execução somente se houver blocos no espaço de trabalho
                        if(code != ''){
                       botaoExecutar.disabled = false;
                    }else{
                        botaoExecutar.disabled = true;
                    }

                 }
                });
               
                }



               //funcao responsavel por limpar a área de trabalho blockly
                function resetarEspacoBlockly(){// --> função criada por mim
                                    resetInterpreter();
                                    resetStepUi(false);
                                    setTimeout(function(){
                                        workspace.clear();
                                       
                                    }, 1000); 
                }


                //ENVIAR A QUANTIDADE DE BLOCOS QUE FORAM UTILIZADOS PARA PASSAR A FASE
                function enviarQtdBlocosUsados(qtdBloco){
                    unityInstance.SendMessage('GameController','quantidadeBlocoUsadosNaFase',qtdBloco );
                    console.log('Enviei os blocos = '+ qtdBloco);
                }

                function mostrarCodigo(code){//mostra o codigo utilizado contido nos blocos escolhidos
                    var arrayCode = code.split("\n");
                    var novoCode = '';

                    for(var i=0; i< arrayCode.length; i++){
                        if(arrayCode[i].indexOf("highlightBlock") == -1){
                            novoCode += arrayCode[i]+"\n";
                        }
                    }

                    return novoCode;
                }

                function msgDesempenhoBloco(qtdBlocosMinimos , qtdBlocosUsados){
                    if(qtdBlocosUsados <= qtdBlocosMinimos){
                        return "Parabéns pelo seu desempenho!!";
                    }else if(qtdBlocosUsados > qtdBlocosMinimos){
                        return "Parabéns, você concluiu a fase usando "+qtdBlocosUsados+" blocos, mais a fase poderia ter sido concluída usando "+qtdBlocosMinimos+" !!";
                    }
                }
                function chamandoAlertDesempenho(){

                    setTimeout(function(){
                        alert( msgDesempenhoBloco(qtdBlocosMinimos, qtdBlocosTotais)+"\n" + 
                                            "Código utilizado para concluir a fase: \n"+
                                            mostrarCodigo(codeCompleto) );
                    codeCompleto = '';
                    qtdBlocosTotais = 0;
                    }, 1000);
                    
                }
               
                
              </script>
</body>
</html>