<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main World</title>
    <!--Unity na pagina-->
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <script src="TemplateData/UnityProgress.js"></script>
    <script src="%UNITY_WEBGL_LOADER_URL%"></script>

    
    <script>
        var unityInstance = UnityLoader.instantiate("unityContainer", "%UNITY_WEBGL_BUILD_URL%", {onProgress: UnityProgress});
      </script>

      <!--JS-->
    <script src="js/acorn_interpreter.js"></script>
    <script src="js/blockly_compressed.js"></script>
    <script src="js/blocks_compressed.js"></script>
    <script src="js/javascript_compressed.js"></script>
    <script src = "msg/js/pt-br.js" > </script> 
    <script src = "js/storage.js" > </script>
    <!--Blocos Customizados-->
      <script src="js/Blocos Personalizados/Definicao_Blocos.js"></script>
      <script src="js/Blocos Personalizados/Estrutura_Blocos.js"></script>
    <!--Fim blocos customizados-->
    <script src="js/focoPagina.js"></script>
    <script src="js/DisableEnableWorkspace.js"></script>
    <script src="js/ControleConclusaoFase.js"></script>
    
    <!--CSS-->
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<!--Local destinado aos blocos blockly-->
<div id="blocklyDiv" style = " height : 480px ; width : 350px ; " onclick="focusCanvas(0)">

    <xml id="toolbox" style="display: none">
        <category name = "Personagem">
            <block type="avancar" class="bloco" disabled = "true"></block>
            <block type="pular" class="bloco" disabled = "true"></block>
            <block type="pular_frente" class="bloco" disabled = "true"></block>
            <block type="defender" class="bloco" disabled = "true"></block>
            <block type="atacar" class="bloco" disabled = "true"></block>
        </category>
        <category name = "Estruturas">
            <block type="controls_if" class="bloco" disabled = "true"></block>
            <block type="controls_repeat_ext" class="bloco" disabled = "true"></block>
            <block type="math_number" class="bloco" disabled = "true"></block>
        </category>
        <category name ="Condições">
            <block type="ha_inimigos" class="bloco" disabled = "true"></block>
            <block type="nao_ha_inimigos" class="bloco" disabled = "true"></block>
        </category>
      </xml>
     
      
  </div>
  <!--Área responsável por mostrar o código em tempo real-->
  <div>
    <p  id="capacRestanteBloco" hidden = true>Restam <span id="capacidade">0</span> blocos !!</p>
</div>
  <div >
   <p>
      <div class="botao" id="execute" disabled = true onclick="stepCode()">
            <img  class="icone-play" src="img/botãoPlay.png" alt="botao de play">
            <p class="execute">Executar</p>
        
        </div>
      
        <!-- <button  class="botao" onclick="teste()" id="execute" >
            <img  class="icone-play" src="img/botãoPlay.png" alt="botao de play">
            <p class="execute">Executar</p>
        
        
        </button>-->
    <!--<button onclick="stepCode()" id="execute" disabled = true></button>
    <button onclick="resetarEspacoBlockly()" id="reset" disabled = true>Reset</button>--APAGAR DEPOIS  -->
   </p>
  
  </div>
  
  <div class="webgl-content" style="margin-left: 200px;float: right; " onclick="focusCanvas(1)">
    <div id="unityContainer" style="width: 960px; height: 600px; "></div>
   
  </div>
    <script>

   // var areaTexto = document.getElementById('textarea'); apagar depois
    var botaoExecute = document.getElementById('execute');
    var botaoReset = document.getElementById('reset');
//----------------------------------------------------------------------------------------------------
    var myInterpreter = null;
    var runner;
    var code = '';
    var highlightPause = false;
    var qtdBlocosUsados = 0;
    var passeiFase = false;//variavel utilizada para saber se passei ou não de fase

                var workspace = Blockly.inject('blocklyDiv',
                    {toolbox: document.getElementById('toolbox'),
                    zoom:
                    {controls: true,
                     wheel: true,
                     startScale: 1.0,
                     maxScale: 3,
                     minScale: 0.3,
                     scaleSpeed: 1.2},
                     trashcan: true,
                     maxBlocks:0 } //define o maximo de bloco que pode ser usado por fase
                     );

                

                function initApi(interpreter , scope){
                    //Adiciona uma função de API ao alert
                    var wrapper = function(text) {
                        return alert(arguments.length ? text : '');
                        };
                        interpreter.setProperty(scope, 'alert',
                             interpreter.createNativeFunction(wrapper));

                    //Adiciona uma função de API para o bloco de prompt
                    var wrapper = function(text){
                        return interpreter.createPrimitive(prompt(text));
                        };
                        interpreter.setProperty(scope, prompt , 
                                 interpreter.createNativeFunction(wrapper));


                        //Adicionando uma função de API para destacar blocos.
                         var wrapper = function(id) {
                                return interpreter.createPrimitive(highlightBlock(id));
                                };
                                interpreter.setProperty(scope, 'highlightBlock',
                                   interpreter.createNativeFunction(wrapper));

                        // MOVIMENTAÇÃO DO PERSONAGEM        
                            
                        //Adicionando uma função de API para movimentação para frente
                        var wrapper = function(){
                            return  unityInstance.SendMessage('playerKnight','Movimentacao' , 'avancar');//arrumar depois para movimentar o player para frente
                        }
                        interpreter.setProperty(scope, 'avancar',
                            interpreter.createNativeFunction(wrapper));

                        //Adicionando uma função de API para pular
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao','puloSimples');
                        }
                        interpreter.setProperty(scope,'pular',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de salto com impulso para frente
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'puloLateral');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'pular_frente',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de defesa
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'defender');
                        }
                        interpreter.setProperty(scope, 'defender',
                            interpreter.createNativeFunction(wrapper));
                        
                        //Adicionando uma função de API para movimentação de ataque
                        var wrapper = function(){
                            return unityInstance.SendMessage('playerKnight','Movimentacao', 'atacar');
                        }
                        interpreter.setProperty(scope, 'atacar',
                            interpreter.createNativeFunction(wrapper));

                    // BLOCOS DE CONDIÇÃO

                    //Adicionando uma função de API para bool há inimigos
                    var wrapper = function(){
                            return unityInstance.SendMessage('PlayerController','Movimentacao', 'ha_inimigos');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'ha_inimigos',
                            interpreter.createNativeFunction(wrapper));
                    
                    //Adicionando uma função de API para bool não há inimigos
                    var wrapper = function(){
                            return unityInstance.SendMessage('PlayerController','Movimentacao', 'nao_ha_inimigos');//arrumar depois
                        }
                        interpreter.setProperty(scope, 'nao_ha_inimigos',
                            interpreter.createNativeFunction(wrapper));
                        

                        
                }
                
                //Carregue o intérprete agora e após alterações futuras
                generateCodeAndLoadIntoInterpreter();
                workspace.addChangeListener(function(event){
                    if(!(event instanceof Blockly.Events.Ui)){
                        resetInterpreter();
                        generateCodeAndLoadIntoInterpreter();
                        //habilita o botão de execução somente se houver blocos no espaço de trabalho
                        if(code != ''){
                        botaoExecute.disabled = false;
                        botaoReset.disabled = false;//mexer aqui depois
                        
                    }else{
                        botaoExecute.disabled = true;
                        botaoReset.disabled = true;
                    }///linkar isso ao novo espaco de trabalho

                    }
                });

                //Adiciona destaque ao bloco que esta sendo executado
                function highlightBlock(id) {
                    workspace.highlightBlock(id);
                    highlightPause = true;
                }
                //reseta o interprete de codigo
                function resetInterpreter(){
                    myInterpreter = null;
                    if(runner){
                        clearTimeout(runner);
                        runner = null;
                    }
                }

                function resetStepUi(clearOutput){
                    workspace.highlightBlock(null);
                    highlightPause = false;
                        /*
                    if(clearOutput){
                       // areaTexto.value = 'Saída do programa: \n -----------------------\n'; apagar depois
                    }*/
                }

                function generateCodeAndLoadIntoInterpreter(){
                    //Código JavaScript gerado e analisado
                    Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n'; 
                    Blockly.JavaScript.addReservedWords('highlightBlock');
                    code = Blockly.JavaScript.workspaceToCode(workspace);
                    resetStepUi(true);
                }

                
                //função responsavel pelo execução do blocos
                function stepCode(){

                    qtdBlocosUsados = workspace.getAllBlocks().length;
                    enviarQtdBlocosUsados(qtdBlocosUsados);

                    if(!myInterpreter){
                        //primeira declaração deste código
                        //limpe a saída do programa
                        resetStepUi(true);
                        execute.disable = 'disable';
                        //E, em seguida, mostre o código gerado em um alerta
                        //Em um tempo limite para permitir que o textarea.value seja redefinido primeiro
                        setTimeout(function(){
                            alert('Pronto para executar o seguinte código\n'+
                                   '===================================\n' + code);

                    highlightPause = false;
                    myInterpreter = new Interpreter(code , initApi);
                    runner = function(){
                        if(myInterpreter){
                            var masCodigo = myInterpreter.step();
                            if(masCodigo){
                                setTimeout(runner,80);//AQUI EH A CHAVE
                            }else{
                                alert("Você falhou, vou resetar o workspace");
                               
                                   //faz algo quando o codigo acabar de ser lido (Ex: resetar a area de trabalho ao passar de fase)
                              var verificarConclusaoFase = function(){  if(!passeiFase){//se passeiFase() returnar false quer dizer que não passei de fase
                                 unityInstance.SendMessage("PainelDerrotaFase","ativarFaseIncompleta");
                                 console.log("Entrei na funcao verificarConclusaFase");
                                    resetarEspacoBlockly();
                                    passeiFase = false;
                                    
                                }
                              }
                              setTimeout(verificarConclusaoFase, 1000);
                            }
                        }
                    };
                    runner();
                },1);
                return;
            }
        }
          

                
               //Atualiza a quantidade de blocos 
                function onchange(event){
                            document.getElementById('capacidade').textContent = 
                                workspace.remainingCapacity();

                        }

                    workspace.addChangeListener(onchange);
               
             

                //funcao responsavel por recriar o workspace toda vez que for iniciar uma nova fase,  alterando o limite de blocos
                function recriarWorkspace(qtdMaxBlocos){// -->  função criada por mim
                    code = '';
                    passeiFase = false;
                    workspace.dispose();
                   workspace = Blockly.inject('blocklyDiv',
                    {toolbox: document.getElementById('toolbox'),
                    zoom:
                    {controls: true,
                     wheel: true,
                     startScale: 1.0,
                     maxScale: 3,
                     minScale: 0.3,
                     scaleSpeed: 1.2},
                     trashcan: true,
                     maxBlocks:qtdMaxBlocos } //define o maximo de bloco que pode ser usado por fase
                     );

                     document.getElementById('capacidade').innerHTML =  workspace.remainingCapacity();
                        //aplica a funcao ao novo espaco de trabalho
                     function onchange(event){
                            document.getElementById('capacidade').textContent = 
                                workspace.remainingCapacity();//funcao responsavel por diminuir o numero de blocos disponiveis cada vez que um bloco é acrescentado ao espaco de trabalho
                        }

                    workspace.addChangeListener(onchange);
                    onchange();

                    workspace.addChangeListener(function(event){
                    if(!(event instanceof Blockly.Events.Ui)){
                        resetInterpreter();
                        generateCodeAndLoadIntoInterpreter();
                        //habilita o botão de execução somente se houver blocos no espaço de trabalho
                        if(code != ''){
                        botaoExecute.disabled = false;
                        botaoReset.disabled = false;//mexer aqui depois
                        
                    }else{
                        botaoExecute.disabled = true;
                        botaoReset.disabled = true;
                    }///linkar isso ao novo espaco de trabalho

                    }
                });
               
                }

               //funcao responsavel por limpar a área de trabalho blockly
                function resetarEspacoBlockly(){// --> função criada por mim
                                    resetInterpreter();
                                    resetStepUi(false);
                                    setTimeout(function(){
                                        workspace.clear();
                                       
                                    }, 1000); 
                }


                //ENVIAR A QUANTIDADE DE BLOCOS QUE FORAM UTILIZADOS PARA PASSAR A FASE
                function enviarQtdBlocosUsados(qtdBloco){
                    unityInstance.SendMessage('GameController','quantidadeBlocoUsadosNaFase',qtdBloco );
                    console.log('Enviei os blocos = '+ qtdBloco);
                }

                function teste(){
                    alert("Cliquei");
                }
                
              </script>
</body>
</html>